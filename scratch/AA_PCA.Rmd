---
title: "PCA_AA"
author: "Eric Witte"
date: "2024-10-02"
output: html_document
---

#### Principal Component Analysis applied directly to Sequence Matrix 
####  Tomokazu Konishi

##### R scripts for calculations

#load packages

library(readxl)

setwd("/Users/ericwitte/Documents/GitHub/Origins_of_Fish_Venoms")

ven_dat<- read_xlsx(path = "data/0930_seqs.xlsx", col_names = TRUE)

head(ven_dat)

### reading the aligned sequence data:
ven_dat <- read_xlsx(path = "data/0930_seqs.xlsx", sheet = 1, col_names = TRUE)

head(ven_dat)

ven_dat<- as.matrix(ven_dat)
dim(ven_dat)

##full seqs

n_sample <- dim(ven_dat)[1]
n_seq <- nchar(ven_dat[1,3])

#translation of the sequence to boolean vectors

bool <- array(0, dim=c(n_sample, 21*n_seq))


colnames(bool) <- c(paste("A_", 1:n_seq, sep=""),paste("C_", 1:n_seq, sep=""),paste("D_", 1:n_seq, sep=""),paste("E_", 1:n_seq, sep=""),paste("F_", 1:n_seq, sep=""),paste("G_", 1:n_seq, sep=""),paste("H_", 1:n_seq, sep=""),paste("I_", 1:n_seq, sep=""),paste("K_", 1:n_seq, sep=""),paste("L_", 1:n_seq, sep=""),paste("M_", 1:n_seq, sep=""),paste("N_", 1:n_seq, sep=""),paste("P_", 1:n_seq, sep=""),paste("Q_", 1:n_seq, sep=""),paste("R_", 1:n_seq, sep=""),paste("S_", 1:n_seq, sep=""),paste("T_", 1:n_seq, sep=""),paste("V_", 1:n_seq, sep=""),paste("W_", 1:n_seq, sep=""),paste("Y_", 1:n_seq, sep=""),paste("-_", 1:n_seq, sep=""))

rownames(bool) <- ven_dat$seq_name


  for (s in 1:n_sample){
     se <- ven_dat[s, 3]
     se <- tolower(se)

	for (le in  1:n_seq){

	 base <- substr(se, le,le)
 
	if(base =="a") {
	bool[s, le] <-1
		} else {

	if(base =="c") {
	bool[s, le+n_seq] <-1
		} else {

	if(base =="d") {
	bool[s, le+n_seq*2] <-1
		} else {

	if(base =="e") {
	bool[s, le+n_seq*3] <-1
		} else {

	if(base =="f") {
	bool[s, le+n_seq*4] <-1
		} else {

	if(base =="g") {
	bool[s, le+n_seq*5] <-1
		} else {

	if(base =="h") {
	bool[s, le+n_seq*6] <-1
		} else {

	if(base =="i") {
	bool[s, le+n_seq*7] <-1
		} else {

	if(base =="k") {
	bool[s, le+n_seq*8] <-1
		} else {

	if(base =="l") {
	bool[s, le+n_seq*9] <-1
		} else {

	if(base =="m") {
	bool[s, le+n_seq*10] <-1
		} else {

	if(base =="n") {
	bool[s, le+n_seq*11] <-1
		} else {

	if(base =="p") {
	bool[s, le+n_seq*12] <-1
		} else {

	if(base =="q") {
	bool[s, le+n_seq*13] <-1
		} else {

	if(base =="r") {
	bool[s, le+n_seq*14] <-1
		} else {

	if(base =="s") {
	bool[s, le+n_seq*15] <-1
		} else {

	if(base =="t") {
	bool[s, le+n_seq*16] <-1
		} else {

	if(base =="v") {
	bool[s, le+n_seq*17] <-1
		} else {

	if(base =="w") {
	bool[s, le+n_seq*18] <-1
		} else {

	if(base =="y") {
	bool[s, le+n_seq*19] <-1
		} else {

	if(base =="-") {
	bool[s, le+n_seq*20] <-1

	}}}}}}}}}}}}}}}}}}}}}
	}}
	
	#PCA
	## centering : the center can be replaced to certain group
	center<- apply(bool, 2, mean)
	diffs<-sweep(bool, 2, center)
        diffs<-diffs/2^0.5  # dounble counting
	# checking distribution of the distances
    		dist<- (apply(diffs^2, 1, sum)/n_seq)^0.5
        	qqnorm(dist)
		hist(dist)
		
			# you can specify the range of sequence used in the calculation by replacing the removed range with zero;
	# for example, this will reproduce the result shown in the test.
   #		 diffs[,c(1:47, 1:47+n_seq, 1:47+2*n_seq,1:47+3*n_seq,1:47+4*n_seq)  ] <- 0   # removes the first 47 sites.
   #		 diffs[, c(248:n_seq, 248:n_seq+n_seq, 248:n_seq+2*n_seq,248:n_seq+3*n_seq, 248:n_seq+4*n_seq) ] <- 0   # removes the last 53 sites.
  
### PCA core
	
	res_svd <- svd(diffs)  #
	str(res_svd)
			Left <- res_svd$u		# the left singular vectors
			Right <- res_svd$v		# the right singular vectors
			sqL <- diag(res_svd$d)		# diagonal matrix of the singular values

 	### calculating of pc's 
	sPC_res  	<-	 Right %*% sqL / (n_sample^0.5)
	sPC_sample	 <-	 Left %*% sqL/ (n_seq^0.5)

	rownames(sPC_res)<- colnames(bool) 
 	rownames(sPC_sample)<- rownames(bool) 

write.table(sPC_sample, file="sPC_sample_full.txt", sep="\t")
	write.table(sPC_res, file="sPC_res_full.txt", sep="\t")

(sum(diffs^2)/n_seq)^0.5

#### output to png images
# sample
	png(width=2100, height=2300, pointsize = 80, file="figs/0310_sPC_full_aa.png")
	  par(lwd=4, mex=0.6, mai=c(4,4,3,0.2))
  	  plot( sPC_sample [,1], sPC_sample[,2], col="gray50" ,  pch=1, main="sample", xlab="", ylab="" , axes=T)
	dev.off()

# sites
	png(width=2100, height=2300, pointsize = 80, file="figs/0310_sPC_res_full_aa.png")
	  par(lwd=4, mex=0.6, mai=c(4,4,3,0.2))
  	  plot( sPC_res [,1], sPC_res[,2], col="gray50" ,  pch=1, main="residure", xlab="", ylab="" , axes=T)
	dev.off()

 # contribution
	png(width=2100, height=2300, pointsize = 80, file="figs/0310_full_contributions.png")
	  par(lwd=4, mex=0.6, mai=c(4,4,3,0.2))
	  plot(1:20, (res_svd$d/sum(res_svd$d)*100)[1:20], pch=1, type="b",  lty=3, ylab="(%)", xlab="PC", main="Contribution", col="gray50")
	dev.off()


# 3D presentation
  install.packages("rgl")
  library("rgl")
  library(ggplot2)

 plot3d( sPC_sample [,1], sPC_sample[,2], sPC_sample[,3], col="black", pch=NA, main="Stx", xlab="sPC1", ylab="sPC2", zlab="sPC3", type="p")
 #  text3d( sPC_sample [,1], sPC_sample[,2], sPC_sample[,3], texts=sites[,1], cex=.5, col="gray50", font=1)
 writeWebGL(width=700)


plot(sPC_sample[,1],sPC_sample[,3], col = "black", xlab="sPC1", ylab= "sPC3")



library(ggplot2)

df_sPC_sample <- as.data.frame(sPC_sample)

df_sPC_sample$subunit <- ven_dat$subunit

View(df_sPC_sample)

ggplot(df_sPC_sample, aes(x=V4, y=V6, col = subunit)) + geom_point()




##gblocks_seqs
n_sample_gb <- dim(ven_dat)[1]
n_seq_gb <- nchar(ven_dat[1,4])

#translation of the sequence to boolean vectors

bool_gb <- array(0, dim=c(n_sample_gb, 21*n_seq_gb))


colnames(bool_gb) <- c(paste("A_", 1:n_seq_gb, sep=""),paste("C_", 1:n_seq_gb, sep=""),paste("D_", 1:n_seq_gb, sep=""),paste("E_", 1:n_seq_gb, sep=""),paste("F_", 1:n_seq_gb, sep=""),paste("G_", 1:n_seq_gb, sep=""),paste("H_", 1:n_seq_gb, sep=""),paste("I_", 1:n_seq_gb, sep=""),paste("K_", 1:n_seq_gb, sep=""),paste("L_", 1:n_seq_gb, sep=""),paste("M_", 1:n_seq_gb, sep=""),paste("N_", 1:n_seq_gb, sep=""),paste("P_", 1:n_seq_gb, sep=""),paste("Q_", 1:n_seq_gb, sep=""),paste("R_", 1:n_seq_gb, sep=""),paste("S_", 1:n_seq_gb, sep=""),paste("T_", 1:n_seq_gb, sep=""),paste("V_", 1:n_seq_gb, sep=""),paste("W_", 1:n_seq_gb, sep=""),paste("Y_", 1:n_seq_gb, sep=""),paste("-_", 1:n_seq_gb, sep=""))

rownames(bool_gb) <- ven_dat$seq_name


  for (s in 1:n_sample_gb){
     se_gb <- ven_dat[s, 4]
     se_gb <- tolower(se_gb)

	for (le in  1:n_seq_gb){

	 base <- substr(se_gb, le,le)
 
	if(base =="a") {
	bool_gb[s, le] <-1
		} else {

	if(base =="c") {
	bool_gb[s, le+n_seq_gb] <-1
		} else {

	if(base =="d") {
	bool_gb[s, le+n_seq_gb*2] <-1
		} else {

	if(base =="e") {
	bool_gb[s, le+n_seq_gb*3] <-1
		} else {

	if(base =="f") {
	bool_gb[s, le+n_seq_gb*4] <-1
		} else {

	if(base =="g") {
	bool_gb[s, le+n_seq_gb*5] <-1
		} else {

	if(base =="h") {
	bool_gb[s, le+n_seq_gb*6] <-1
		} else {

	if(base =="i") {
	bool_gb[s, le+n_seq_gb*7] <-1
		} else {

	if(base =="k") {
	bool_gb[s, le+n_seq_gb*8] <-1
		} else {

	if(base =="l") {
	bool_gb[s, le+n_seq_gb*9] <-1
		} else {

	if(base =="m") {
	bool_gb[s, le+n_seq_gb*10] <-1
		} else {

	if(base =="n") {
	bool_gb[s, le+n_seq_gb*11] <-1
		} else {

	if(base =="p") {
	bool_gb[s, le+n_seq_gb*12] <-1
		} else {

	if(base =="q") {
	bool_gb[s, le+n_seq_gb*13] <-1
		} else {

	if(base =="r") {
	bool_gb[s, le+n_seq_gb*14] <-1
		} else {

	if(base =="s") {
	bool_gb[s, le+n_seq_gb*15] <-1
		} else {

	if(base =="t") {
	bool_gb[s, le+n_seq_gb*16] <-1
		} else {

	if(base =="v") {
	bool_gb[s, le+n_seq_gb*17] <-1
		} else {

	if(base =="w") {
	bool_gb[s, le+n_seq_gb*18] <-1
		} else {

	if(base =="y") {
	bool_gb[s, le+n_seq_gb*19] <-1
		} else {

	if(base =="-") {
	bool_gb[s, le+n_seq_gb*20] <-1

	}}}}}}}}}}}}}}}}}}}}}
	}}
	
	#PCA
	## centering : the center can be replaced to certain group
	center_gb<- apply(bool_gb, 2, mean)
	diffs_gb<-sweep(bool_gb, 2, center)
        diffs_gb<-diffs_gb/2^0.5  # dounble counting
	# checking distribution of the distances
    		dist_gb<- (apply(diffs_gb^2, 1, sum)/n_seq_gb)^0.5
        	qqnorm(dist_gb)
		hist(dist_gb)
		
			# you can specify the range of sequence used in the calculation by replacing the removed range with zero;
	# for example, this will reproduce the result shown in the test.
   #		 diffs[,c(1:47, 1:47+n_seq, 1:47+2*n_seq,1:47+3*n_seq,1:47+4*n_seq)  ] <- 0   # removes the first 47 sites.
   #		 diffs[, c(248:n_seq, 248:n_seq+n_seq, 248:n_seq+2*n_seq,248:n_seq+3*n_seq, 248:n_seq+4*n_seq) ] <- 0   # removes the last 53 sites.
  
### PCA core
	
	res_svd_gb <- svd(diffs_gb)  #
	str(res_svd_gb)
			Left_gb <- res_svd_gb$u		# the left singular vectors
			Right_gb <- res_svd_gb$v		# the right singular vectors
			sqL_gb <- diag(res_svd_gb$d)		# diagonal matrix of the singular values

 	### calculating of pc's 
	sPC_res_gb  	<-	 Right_gb %*% sqL_gb / (n_sample_gb^0.5)
	sPC_sample_gb	 <-	 Left_gb %*% sqL_gb/ (n_seq_gb^0.5)

	rownames(sPC_res_gb)<- colnames(bool_gb) 
 	rownames(sPC_sample_gb)<- rownames(bool_gb) 

write.table(sPC_sample_gb, file="sPC_sample_gb.txt", sep="\t")
	write.table(sPC_res_gb, file="sPC_res_gb.txt", sep="\t")

(sum(diffs_gb^2)/n_seq_gb)^0.5

#### output to png images
# sample
	png(width=2100, height=2300, pointsize = 80, file="figs/0310_sPC_gb_aa.png")
	  par(lwd=4, mex=0.6, mai=c(4,4,3,0.2))
  	  plot( sPC_sample_gb [,1], sPC_sample_gb[,2], col="gray50" ,  pch=1, main="sample", xlab="", ylab="" , axes=T)
	dev.off()

# sites
	png(width=2100, height=2300, pointsize = 80, file="figs/0310_sPC_res_gb_aa.png")
	  par(lwd=4, mex=0.6, mai=c(4,4,3,0.2))
  	  plot( sPC_res_gb [,1], sPC_res_gb[,2], col="gray50" ,  pch=1, main="residure", xlab="", ylab="" , axes=T)
	dev.off()

 # contribution
	png(width=2100, height=2300, pointsize = 80, file="figs/0310_aa_gb_contributions.png")
	  par(lwd=4, mex=0.6, mai=c(4,4,3,0.2))
	  plot(1:20, (res_svd_gb$d/sum(res_svd_gb$d)*100)[1:20], pch=1, type="b",  lty=3, ylab="(%)", xlab="PC", main="Contribution", col="gray50")
	dev.off()


# 3D presentation
  install.packages("rgl")
  library("rgl")
  library(ggplot2)

 plot3d( sPC_sample [,1], sPC_sample[,2], sPC_sample[,3], col="black", pch=NA, main="Stx", xlab="sPC1", ylab="sPC2", zlab="sPC3", type="p")
 #  text3d( sPC_sample [,1], sPC_sample[,2], sPC_sample[,3], texts=sites[,1], cex=.5, col="gray50", font=1)
 writeWebGL(width=700)


plot(sPC_sample[,1],sPC_sample[,3], col = "black", xlab="sPC1", ylab= "sPC3")



library(ggplot2)

df_sPC_sample_gb <- as.data.frame(sPC_sample_gb)

df_sPC_sample_gb$subunit <- ven_dat$subunit

View(df_sPC_sample_gb)

ggplot(df_sPC_sample_gb, aes(x=V1, y=V5, col = subunit)) + geom_point()

